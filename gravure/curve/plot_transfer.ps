%!PS-Adobe-3.0  EPSF-3.0
%%BoundingBox:  0 0 400 425
%%Title:        Plot Transfer
%%CreationDate: Jan.30,2013

% Copyright (C) 2012 Atelier Obscur.
% Authors:
% Gilles Coissac <dev@atelierobscur.org>
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of version 2 of the GNU General Public License
% as published by the Free Software Foundation.
%
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
% or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
% for more details.
%
% You should have received a copy of the GNU General Public License with
% the Debian GNU/Linux distribution in file /usr/share/common-licenses/GPL;
% if not, write to the Free Software Foundation, Inc., 51 Franklin St,
% Fifth Floor, Boston, MA 02110-1301, USA.
%

%
% Parts of this file (some graphic procedures)
% are taken from the pdf << PS-Tutor Function Graphs
% and Other Applications for PostScript >>
% by Gernot Hoffmann.
%

% points per mm
/mm {2.834646 mul} def

% plotting resolution,
% n steps for 0..1
/plot_res 100 def

% length of x-axis and y-axis, global scaling
/x_scale 100 mm def
/y_scale 100 mm def

% grid subdivision
/x_grid 10 def
/y_grid 10 def

% background box
/box_width x_scale 20 mm add def
/box_height y_scale 30 mm add def

% origin of x-y-coordinates
/x_orig 20 mm def
/y_orig 30 mm def

% start and end of axes
/x_start x_orig def
/x_end x_orig x_scale add def

/y_start y_orig def
/y_end y_orig y_scale add def

/lw 0.2 mm def % standard linewidth

% construction grid procedure
/Grid
{ newpath
  % grid color
  0 0 0 0.5 setcmykcolor
  0.1 mm setlinewidth
  % grid step
  /gx x_orig def /x_step x_scale x_grid div def
  /gy y_orig def /y_step y_scale y_grid div def
  % horizontal lines
  { gx gy moveto
    gx x_scale add gy lineto stroke
    /gy gy y_step add def
    gy y_end  x_step add gt {exit}if } loop
    /gy y_orig def
  % vertical lines
  { gx gy moveto
    gx gy y_scale add lineto stroke
    /gx gx x_step add def
    gx x_end y_step add gt {exit}if } loop
} def

/Axes
{
    newpath
    % x-axes
    x_orig y_orig moveto
    x_end y_orig lineto
    % y-axes
    x_orig y_start moveto
    x_orig y_end lineto
    lw 2 mul setlinewidth
    0.0 setgray
    stroke
    % linear value line
    x_orig y_orig moveto
    x_end y_end lineto
    0.2 setgray
    lw setlinewidth
    stroke
} def

/Box
{ newpath
  0.95 setgray
  x_orig 10 mm sub y_orig 20 mm sub moveto
  box_width 10 mm add y_orig 20 mm sub lineto
  box_width 10 mm add box_height 10 mm add lineto
  x_orig 10 mm sub box_height 10 mm add lineto
  closepath
  fill
  newpath
  0.72 setgray
  x_orig 10 mm sub y_orig 20 mm sub moveto
  box_width 10 mm add y_orig 20 mm sub lineto
  box_width 10 mm add box_height 10 mm add lineto
  x_orig 10 mm sub box_height 10 mm add lineto
  closepath
  stroke
} def

/Gray_ramp
{
  .2 mm setlinewidth
  0 .2 mm x_scale {
    dup x_scale div 1 exch sub setgray
    newpath
    x_orig add dup y_orig 10 mm sub moveto
    y_orig 5 mm sub lineto
    stroke
  } for
  %newpath
  x_orig y_orig 10 mm sub moveto
  x_orig y_orig 5 mm sub lineto
  x_scale x_orig add y_orig 5 mm sub lineto
  0.3 setgray
  stroke
} def

% transfer function
/trs
{
  % Dot Gain Table
  % REF VALUE | MEASURED GAIN VALUE
  % Define tables x,y(x) by any number of entries.
  % Values for x=0.0 and x=1.0 are compulsary.
  /Tab
  [ 0.00  0.00  %   0% White
%    0.02  0.02  %   2%
%    0.04  0.04  %   4%
%    0.06  0.06  %   6%
%    0.08  0.08  %   8%
%    0.10  0.10  %  10%
%    0.15  0.15  %  15%
%    0.20  0.20  %  20%
%    0.30  0.30  %  30%
%    0.40  0.40  %  40%
%    0.45  0.45  %  45%
     0.50  0.70  %  50%
%    0.55  0.55  %  55%
%    0.60  0.60  %  60%
%    0.70  0.70  %  70%
%    0.80  0.80  %  80%
%    0.85  0.85  %  85%
%    0.90  0.90  %  90%
%    0.92  0.92  %  92%
%    0.94  0.94  %  94%
%    0.96  0.96  %  96%
%    0.98  0.98  %  98%
    1.00  1.00 % 100% Black
  ] def

  % convert from grey postcript
  % value to % ink coverage
  /cvink {1 exch sub} def

  % reverse table order and
  % reverse (x,y) value pair
  % to guess corrected value
  % from input value.
  /tab_reverse
  {
    /tmp_tab exch def
    tmp_tab aload length
    0 2 3 -1 roll 1 sub {
      /pos exch def
      tmp_tab exch pos exch put
      tmp_tab exch pos 1 add exch put
    } for
  } def

  % convert soustractiv input table
  % to postscript additiv values
  /to_additiv_tab
  {
    /tmp_tab exch def
    0 1 tmp_tab length 1 sub
    {
      dup
      tmp_tab exch get cvink
      tmp_tab 3 1 roll put
    } for
  } def

  % Linear interpolation function
  % guess value from table
  % with (x,y) value pair
  /get_y
  {
    /tab_length Tab length 1 sub def
    /ib 0 def
    % stack -> input_val
    {
      /ib ib 2 add def             % ib = ib + 2
      ib tab_length gt {exit} if   % if ib>tab_length : exit loop
      dup                          % stack -> input_val | input_val
      Tab ib get le {exit} if      % if input_val<=tab[ib] : exit loop
    } loop                         % loop keep index position in /ib

    % stack -> input_val
    Tab ib 2 sub get sub     % (input_val - Tab[ib-2])
    Tab ib 1 add get         % *
    Tab ib 1 sub get sub mul % (Tab[ib+1] - Tab[ib-1])
    Tab ib get               % stack -> resultat | Tab[ib]
    Tab ib 2 sub get sub     % Tab[ib] - Tab[ib-2]
    div                      % resultat / resultat2
    Tab ib 1 sub get add     % + Tab[ib-1]
  } def

  Tab to_additiv_tab
  Tab tab_reverse
  get_y
} def


% convert from grey postcript
% value to % ink coverage
/cvink {1 exch sub} def


% plotting procedures
/plot_correction
{ newpath
  x_orig 0 trs y_scale mul y_orig add moveto
  0 1.0 plot_res div 1.0
  {
    dup cvink trs cvink
    y_scale mul y_orig add
    exch
    x_scale mul x_orig add
    exch lineto
  } for
  0 .6 0.3 setrgbcolor
  lw 2 mul setlinewidth
  [3 mm 3 mm] 0 setdash
  stroke
} def


/plot_gain
{ newpath
  x_orig 0 trs y_scale mul y_orig add moveto
  0 1.0 plot_res div 1.0
  {
    dup cvink trs cvink
    y_scale mul x_orig add
    exch
    x_scale mul y_orig add
    lineto
  } for
  1 0 1 setrgbcolor
  lw setlinewidth
  [] 0 setdash stroke
} def

%â€”Program
true setstrokeadjust
gsave
Box
Grid
Axes
Gray_ramp
2 setlinecap % 0=short 1=round 2=long
plot_correction
plot_gain

grestore
showpage
